## API Report File for "vaultkeeper"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class AuthorizationDeniedError extends VaultError {
    constructor(message: string);
}

// @public
export interface BackendConfig {
    enabled: boolean;
    options?: Record<string, string> | undefined;
    path?: string | undefined;
    plugin?: boolean | undefined;
    type: string;
}

// @public
export type BackendFactory = () => SecretBackend;

// @public
export class BackendLockedError extends VaultError {
    constructor(message: string, interactive: boolean);
    readonly interactive: boolean;
}

// @public
export class BackendRegistry {
    // @internal
    static clearBackends(): void;
    // @internal
    static clearSetups(): void;
    static create(type: string): SecretBackend;
    static getAvailableTypes(): Promise<string[]>;
    static getSetup(type: string): BackendSetupFactory | undefined;
    static getTypes(): string[];
    static hasSetup(type: string): boolean;
    static register(type: string, factory: BackendFactory): void;
    static registerSetup(type: string, factory: BackendSetupFactory): void;
}

// @public
export type BackendSetupFactory = () => AsyncGenerator<SetupQuestion, SetupResult, string>;

// @public
export class BackendUnavailableError extends VaultError {
    constructor(message: string, reason: string, attempted: string[]);
    readonly attempted: string[];
    readonly reason: string;
}

// @public
export class CapabilityToken {
    constructor();
    toString(): string;
}

// @public
export class DeviceNotPresentError extends VaultError {
    constructor(message: string, timeoutMs: number);
    readonly timeoutMs: number;
}

// @public
export interface ExecRequest {
    args?: string[] | undefined;
    command: string;
    cwd?: string | undefined;
    env?: Record<string, string> | undefined;
}

// @public
export interface ExecResult {
    exitCode: number;
    stderr: string;
    stdout: string;
}

// @public
export interface FetchRequest {
    body?: string | undefined;
    headers?: Record<string, string> | undefined;
    method?: string | undefined;
    url: string;
}

// @public
export class FilesystemError extends VaultError {
    constructor(message: string, filePath: string, permission: string);
    readonly path: string;
    readonly permission: string;
}

// @public
export class IdentityMismatchError extends VaultError {
    constructor(message: string, previousHash: string, currentHash: string);
    readonly currentHash: string;
    readonly previousHash: string;
}

// @public
export class InvalidAlgorithmError extends VaultError {
    constructor(message: string, algorithm: string, allowed: string[]);
    readonly algorithm: string;
    readonly allowed: string[];
}

// @public
export function isListableBackend(backend: SecretBackend): backend is ListableBackend;

// @public
export class KeyRevokedError extends VaultError {
    constructor(message: string);
}

// @public
export class KeyRotatedError extends VaultError {
    constructor(message: string);
}

// @public
export type KeyStatus = 'current' | 'previous' | 'deprecated';

// @public
export interface ListableBackend extends SecretBackend {
    list(): Promise<string[]>;
}

// @public
export class PluginNotFoundError extends VaultError {
    constructor(message: string, plugin: string, installUrl: string);
    readonly installUrl: string;
    readonly plugin: string;
}

// @public
export interface PreflightCheck {
    name: string;
    reason?: string | undefined;
    status: PreflightCheckStatus;
    version?: string | undefined;
}

// @public
export type PreflightCheckStatus = 'ok' | 'missing' | 'version-unsupported';

// @public
export interface PreflightResult {
    checks: PreflightCheck[];
    nextSteps: string[];
    ready: boolean;
    warnings: string[];
}

// @public
export class RotationInProgressError extends VaultError {
    constructor(message: string);
}

// @public
export interface SecretAccessor {
    read(callback: (buf: Buffer) => void): void;
}

// @public
export interface SecretBackend {
    delete(id: string): Promise<void>;
    readonly displayName: string;
    exists(id: string): Promise<boolean>;
    isAvailable(): Promise<boolean>;
    retrieve(id: string): Promise<string>;
    store(id: string, secret: string): Promise<void>;
    readonly type: string;
}

// @public
export class SecretNotFoundError extends VaultError {
    constructor(message: string);
}

// @public
export interface SetupChoice {
    readonly label: string;
    readonly value: string;
}

// @public
export class SetupError extends VaultError {
    constructor(message: string, dependency: string);
    readonly dependency: string;
}

// @public
export interface SetupOptions {
    backendType?: string | undefined;
    executablePath?: string | undefined;
    trustTier?: TrustTier | undefined;
    ttlMinutes?: number | undefined;
    useLimit?: number | null | undefined;
}

// @public
export interface SetupQuestion {
    readonly choices?: readonly SetupChoice[];
    readonly key: string;
    readonly prompt: string;
}

// @public
export interface SetupResult {
    readonly options: Record<string, string>;
}

// @public
export interface SignRequest {
    algorithm?: string | undefined;
    data: string | Buffer;
}

// @public
export interface SignResult {
    algorithm: string;
    signature: string;
}

// @public
export class TokenExpiredError extends VaultError {
    constructor(message: string, canRefresh: boolean);
    readonly canRefresh: boolean;
}

// @public
export class TokenRevokedError extends VaultError {
    constructor(message: string);
}

// @public
export type TrustTier = 1 | 2 | 3;

// @public
export class UsageLimitExceededError extends VaultError {
    constructor(message: string);
}

// @public
export interface VaultConfig {
    backends: BackendConfig[];
    defaults: {
        ttlMinutes: number;
        trustTier: TrustTier;
    };
    developmentMode?: {
        executables: string[];
    } | undefined;
    keyRotation: {
        gracePeriodDays: number;
    };
    version: number;
}

// @public
export class VaultError extends Error {
    constructor(message: string);
}

// @public
export class VaultKeeper {
    authorize(jwe: string): Promise<{
        token: CapabilityToken;
        response: VaultResponse;
    }>;
    static doctor(): Promise<PreflightResult>;
    exec(token: CapabilityToken, request: ExecRequest): Promise<{
        result: ExecResult;
        vaultResponse: VaultResponse;
    }>;
    fetch(token: CapabilityToken, request: FetchRequest): Promise<{
        response: Response;
        vaultResponse: VaultResponse;
    }>;
    getSecret(token: CapabilityToken): SecretAccessor;
    static init(options?: VaultKeeperOptions): Promise<VaultKeeper>;
    revokeKey(): Promise<void>;
    rotateKey(): Promise<void>;
    setDevelopmentMode(executablePath: string, enabled: boolean): Promise<void>;
    setup(secretName: string, options?: SetupOptions): Promise<string>;
    sign(token: CapabilityToken, request: SignRequest): Promise<{
        result: SignResult;
        vaultResponse: VaultResponse;
    }>;
    static verify(request: VerifyRequest): boolean;
}

// @public
export interface VaultKeeperOptions {
    config?: VaultConfig | undefined;
    configDir?: string | undefined;
    skipDoctor?: boolean | undefined;
}

// @public
export interface VaultResponse {
    keyStatus: KeyStatus;
    rotatedJwt?: string | undefined;
}

// @public
export interface VerifyRequest {
    algorithm?: string | undefined;
    data: string | Buffer;
    publicKey: string;
    signature: string;
}

// (No @packageDocumentation comment for this package)

```
