## API Report File for "vaultkeeper"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function addTrustedHash(manifest: TrustManifest, namespace: string, hash: string): TrustManifest;

// @public
export class AuthorizationDeniedError extends VaultError {
    constructor(message: string);
}

// @public
export interface BackendConfig {
    enabled: boolean;
    path?: string | undefined;
    plugin?: boolean | undefined;
    type: string;
}

// @public
export type BackendFactory = () => SecretBackend;

// @public
export class BackendLockedError extends VaultError {
    constructor(message: string, interactive: boolean);
    readonly interactive: boolean;
}

// @public
export class BackendRegistry {
    static create(type: string): SecretBackend;
    static getTypes(): string[];
    static register(type: string, factory: BackendFactory): void;
}

// @public
export class BackendUnavailableError extends VaultError {
    constructor(message: string, reason: string, attempted: string[]);
    readonly attempted: string[];
    readonly reason: string;
}

// @public
export function blockToken(jti: string): void;

// @public
export class CapabilityToken {
    constructor();
    toString(): string;
}

// @public
export function checkBash(): Promise<PreflightCheck>;

// @public
export function checkOp(): Promise<PreflightCheck>;

// @public
export function checkOpenssl(): Promise<PreflightCheck>;

// @public
export function checkPowershell(): Promise<PreflightCheck>;

// @public
export function checkSecretTool(): Promise<PreflightCheck>;

// @public
export function checkSecurity(): Promise<PreflightCheck>;

// @public
export function checkYkman(): Promise<PreflightCheck>;

// @public
export function clearBlocklist(): void;

// @public
export function createCapabilityToken(claims: VaultClaims): CapabilityToken;

// @public
export function createSecretAccessor(secretValue: string): SecretAccessor;

// @public
export function createToken(key: Uint8Array, claims: VaultClaims, options?: CreateTokenOptions): Promise<string>;

// @public
export interface CreateTokenOptions {
    kid?: string | undefined;
}

// @public
export function decryptToken(key: Uint8Array, jwe: string): Promise<VaultClaims>;

// @public
export function delegatedExec(secret: string, request: ExecRequest): Promise<ExecResult>;

// @public
export function delegatedFetch(secret: string, request: FetchRequest): Promise<Response>;

// @public
export interface DelegatedFetchResult {
    // (undocumented)
    response: Response;
}

// @public
export class DeviceNotPresentError extends VaultError {
    constructor(message: string, timeoutMs: number);
    readonly timeoutMs: number;
}

// @public
export type DoctorCheckFn = (check: {
    name: string;
}) => Promise<PreflightCheck>;

// @public
export class DpapiBackend implements SecretBackend {
    // (undocumented)
    delete(id: string): Promise<void>;
    // (undocumented)
    readonly displayName = "Windows DPAPI";
    // (undocumented)
    exists(id: string): Promise<boolean>;
    // (undocumented)
    isAvailable(): Promise<boolean>;
    // (undocumented)
    retrieve(id: string): Promise<string>;
    // (undocumented)
    store(id: string, secret: string): Promise<void>;
    // (undocumented)
    readonly type = "dpapi";
}

// @public
export interface ExecRequest {
    args?: string[] | undefined;
    command: string;
    cwd?: string | undefined;
    env?: Record<string, string> | undefined;
}

// @public
interface ExecResult {
    exitCode: number;
    stderr: string;
    stdout: string;
}
export { ExecResult as DelegatedExecResult }
export { ExecResult }

// @public
export function extractKid(jwe: string): string | undefined;

// @public
export interface FetchRequest {
    body?: string | undefined;
    headers?: Record<string, string> | undefined;
    method?: string | undefined;
    url: string;
}

// @public
export class FileBackend implements SecretBackend {
    // (undocumented)
    delete(id: string): Promise<void>;
    // (undocumented)
    readonly displayName = "Encrypted File Store";
    // (undocumented)
    exists(id: string): Promise<boolean>;
    // (undocumented)
    isAvailable(): Promise<boolean>;
    // (undocumented)
    retrieve(id: string): Promise<string>;
    // (undocumented)
    store(id: string, secret: string): Promise<void>;
    // (undocumented)
    readonly type = "file";
}

// @public
export class FilesystemError extends VaultError {
    constructor(message: string, filePath: string, permission: string);
    readonly path: string;
    readonly permission: string;
}

// @public
export function getDefaultConfigDir(): string;

// @public
export function hashExecutable(filePath: string): Promise<string>;

// @public
export interface IdentityInfo {
    hash: string;
    trustTier: TrustTier;
    verified: boolean;
}

// @public
export class IdentityMismatchError extends VaultError {
    constructor(message: string, previousHash: string, currentHash: string);
    readonly currentHash: string;
    readonly previousHash: string;
}

// @public
export function isBlocked(jti: string): boolean;

// @public
export function isTrusted(manifest: TrustManifest, namespace: string, hash: string): boolean;

// @public
export class KeychainBackend implements SecretBackend {
    // (undocumented)
    delete(id: string): Promise<void>;
    // (undocumented)
    readonly displayName = "macOS Keychain";
    // (undocumented)
    exists(id: string): Promise<boolean>;
    // (undocumented)
    isAvailable(): Promise<boolean>;
    // (undocumented)
    retrieve(id: string): Promise<string>;
    // (undocumented)
    store(id: string, secret: string): Promise<void>;
    // (undocumented)
    readonly type = "keychain";
}

// @public
export class KeyManager {
    findKeyById(kid: string): KeyMaterial | undefined;
    generateKey(): KeyMaterial;
    getCurrentKey(): KeyMaterial;
    getPreviousKey(): KeyMaterial | undefined;
    init(): Promise<void>;
    isInGracePeriod(): boolean;
    revokeKey(): void;
    rotateKey(gracePeriodMs: number): void;
}

// @public
export interface KeyMaterial {
    createdAt: Date;
    id: string;
    key: Uint8Array;
}

// @public
export class KeyRevokedError extends VaultError {
    constructor(message: string);
}

// @public
export class KeyRotatedError extends VaultError {
    constructor(message: string);
}

// @public
export interface KeyRotationConfig {
    gracePeriodMs: number;
}

// @public
export interface KeyState {
    current: KeyMaterial;
    previous?: KeyMaterial;
}

// @public
export type KeyStatus = 'current' | 'previous' | 'deprecated';

// @public
export function loadConfig(configDir?: string): Promise<VaultConfig>;

// @public
export function loadManifest(configDir: string): Promise<TrustManifest>;

// @public
export class OnePasswordBackend implements SecretBackend {
    constructor(vault?: string);
    // (undocumented)
    delete(id: string): Promise<void>;
    // (undocumented)
    readonly displayName = "1Password";
    // (undocumented)
    exists(id: string): Promise<boolean>;
    // (undocumented)
    isAvailable(): Promise<boolean>;
    // (undocumented)
    retrieve(id: string): Promise<string>;
    // (undocumented)
    store(id: string, secret: string): Promise<void>;
    // (undocumented)
    readonly type = "1password";
}

// @public
export type Platform = 'darwin' | 'win32' | 'linux';

// @public
export class PluginNotFoundError extends VaultError {
    constructor(message: string, plugin: string, installUrl: string);
    readonly installUrl: string;
    readonly plugin: string;
}

// @public
export interface PreflightCheck {
    name: string;
    reason?: string | undefined;
    status: PreflightCheckStatus;
    version?: string | undefined;
}

// @public
export type PreflightCheckStatus = 'ok' | 'missing' | 'version-unsupported';

// @public
export interface PreflightResult {
    checks: PreflightCheck[];
    nextSteps: string[];
    ready: boolean;
    warnings: string[];
}

// @public
export class RotationInProgressError extends VaultError {
    constructor(message: string);
}

// @public
export function runDoctor(options?: RunDoctorOptions): Promise<PreflightResult>;

// @public
export interface RunDoctorOptions {
    platform?: Platform;
}

// @public
export function saveManifest(configDir: string, manifest: TrustManifest): Promise<void>;

// @public
export interface SecretAccessor {
    read(callback: (buf: Buffer) => void): void;
}

// @public
export interface SecretBackend {
    delete(id: string): Promise<void>;
    readonly displayName: string;
    exists(id: string): Promise<boolean>;
    isAvailable(): Promise<boolean>;
    retrieve(id: string): Promise<string>;
    store(id: string, secret: string): Promise<void>;
    readonly type: string;
}

// @public
export class SecretNotFoundError extends VaultError {
    constructor(message: string);
}

// @public
export class SecretToolBackend implements SecretBackend {
    // (undocumented)
    delete(id: string): Promise<void>;
    // (undocumented)
    readonly displayName = "Linux Secret Service (secret-tool)";
    // (undocumented)
    exists(id: string): Promise<boolean>;
    // (undocumented)
    isAvailable(): Promise<boolean>;
    // (undocumented)
    retrieve(id: string): Promise<string>;
    // (undocumented)
    store(id: string, secret: string): Promise<void>;
    // (undocumented)
    readonly type = "secret-tool";
}

// @public
export class SetupError extends VaultError {
    constructor(message: string, dependency: string);
    readonly dependency: string;
}

// @public
export interface SetupOptions {
    backendType?: string | undefined;
    executablePath?: string | undefined;
    trustTier?: TrustTier | undefined;
    ttlMinutes?: number | undefined;
    useLimit?: number | null | undefined;
}

// @public
export class TokenExpiredError extends VaultError {
    constructor(message: string, canRefresh: boolean);
    readonly canRefresh: boolean;
}

// @public
export class TokenRevokedError extends VaultError {
    constructor(message: string);
}

// @public
export type TrustManifest = Map<string, TrustManifestEntry>;

// @public
export interface TrustManifestEntry {
    hashes: string[];
    trustTier: TrustTier;
}

// @public
export interface TrustOptions {
    configDir?: string | undefined;
    namespace?: string | undefined;
    skipSigstore?: boolean | undefined;
}

// @public
export type TrustTier = 1 | 2 | 3;

// @public
export interface TrustVerificationResult {
    identity: IdentityInfo;
    reason: string;
    tofuConflict: boolean;
}

// @public
export class UsageLimitExceededError extends VaultError {
    constructor(message: string);
}

// @public
export function validateCapabilityToken(token: CapabilityToken): VaultClaims;

// @public
export function validateClaims(claims: VaultClaims, usedCount?: number): void;

// @public
export function validateConfig(config: unknown): VaultConfig;

// @public
export interface VaultClaims {
    bkd: string;
    exe: string;
    exp: number;
    iat: number;
    jti: string;
    ref: string;
    sub: string;
    tid: TrustTier;
    use: number | null;
    val: string;
}

// @public
export interface VaultConfig {
    backends: BackendConfig[];
    defaults: {
        ttlMinutes: number;
        trustTier: TrustTier;
    };
    developmentMode?: {
        executables: string[];
    } | undefined;
    keyRotation: {
        gracePeriodDays: number;
    };
    version: number;
}

// @public
export class VaultError extends Error {
    constructor(message: string);
}

// @public
export interface VaultJWEHeader {
    alg: 'dir';
    enc: 'A256GCM';
    kid?: string | undefined;
}

// @public
export class VaultKeeper {
    authorize(jwe: string): Promise<{
        token: CapabilityToken;
        response: VaultResponse;
    }>;
    static doctor(): Promise<PreflightResult>;
    exec(token: CapabilityToken, request: ExecRequest): Promise<{
        result: ExecResult;
        vaultResponse: VaultResponse;
    }>;
    fetch(token: CapabilityToken, request: FetchRequest): Promise<{
        response: Response;
        vaultResponse: VaultResponse;
    }>;
    getSecret(token: CapabilityToken): SecretAccessor;
    static init(options?: VaultKeeperOptions): Promise<VaultKeeper>;
    revokeKey(): Promise<void>;
    rotateKey(): Promise<void>;
    setDevelopmentMode(executablePath: string, enabled: boolean): Promise<void>;
    setup(secretName: string, options?: SetupOptions): Promise<string>;
}

// @public
export interface VaultKeeperOptions {
    config?: VaultConfig | undefined;
    configDir?: string | undefined;
    skipDoctor?: boolean | undefined;
}

// @public
export interface VaultResponse {
    keyStatus: KeyStatus;
    rotatedJwt?: string | undefined;
}

// @public
export function verifyTrust(execPath: string, options?: TrustOptions): Promise<TrustVerificationResult>;

// @public
export class YubikeyBackend implements SecretBackend {
    // (undocumented)
    delete(id: string): Promise<void>;
    // (undocumented)
    readonly displayName = "YubiKey";
    // (undocumented)
    exists(id: string): Promise<boolean>;
    // (undocumented)
    isAvailable(): Promise<boolean>;
    // (undocumented)
    retrieve(id: string): Promise<string>;
    // (undocumented)
    store(id: string, secret: string): Promise<void>;
    // (undocumented)
    readonly type = "yubikey";
}

```
